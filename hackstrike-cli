#!/bin/bash

#====================================================================
#  HACKSTRIKE CLI - Interactive Command Line Interface
#  A shell-like interface for bug bounty hunting
#====================================================================

set -o pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VERSION="1.0"
TARGET=""
LAST_SCAN_DIR=""
HISTORY_FILE="$SCRIPT_DIR/.hackstrike_history"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
NC='\033[0m'
BOLD='\033[1m'

# Enable history
HISTFILE="$HISTORY_FILE"
HISTSIZE=1000
set -o history

banner() {
    clear
    echo -e "${PURPLE}"
    cat << "BANNER"
   ??????    ??????       ???????????????????????????  ???????????????????????????    ??????   ?????????    ???????????????????????????     ?????????        ???????????????????????????  ??????   ?????????    ??????????????????????????? 
  ?????????    ?????????     ?????????    ????????? ?????????    ?????????   ????????? ???????????????   ?????????    ????????? ?????????????????????????????????   ?????????    ????????? ????????? ???????????????   ?????????    ????????? 
  ?????????    ?????????     ?????????    ????????? ?????????    ??????    ?????????????????????     ?????????    ??????     ????????????????????????   ?????????    ????????? ?????????????????????     ?????????    ??????  
 ???????????????????????????????????????   ?????????    ????????? ?????????         ?????????????????????      ?????????            ?????????   ???  ??????????????????????????????????????????????????????     ?????????????????????     
???????????????????????????????????????  ???????????????????????????????????? ?????????        ????????????????????????    ????????????????????????????????????     ?????????     ?????????????????????????????? ????????????????????????    ????????????????????????     
  ?????????    ?????????     ?????????    ????????? ?????????    ??????    ?????????????????????            ?????????     ?????????     ????????????????????????????????????   ?????????????????????    ?????????    ??????  
  ?????????    ?????????     ?????????    ????????? ?????????    ?????????   ????????? ???????????????    ??????    ?????????     ?????????       ?????????    ?????????   ????????? ???????????????  ?????????    ????????? 
  ?????????    ??????      ?????????    ??????  ???????????????????????????    ?????????   ?????????  ??????????????????????????????     ??????????????????     ?????????    ?????????   ?????????   ?????????  ?????????????????????????????? 
                                         ???                                    ?????????    ?????????   ???                     
BANNER
    echo -e "${NC}"
    echo -e "${CYAN}?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????${NC}"
    echo -e "  ${WHITE}Interactive Bug Bounty CLI${NC}  ${GRAY}v${VERSION}${NC}  ${YELLOW}Type 'help' for commands${NC}"
    echo -e "${CYAN}?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????${NC}"
    echo ""
}

print_help() {
    echo -e "${WHITE}${BOLD}Available Commands:${NC}"
    echo ""
    echo -e "${CYAN}Target Management:${NC}"
    echo -e "  ${GREEN}target${NC} <domain>       Set target domain"
    echo -e "  ${GREEN}target${NC}                Show current target"
    echo -e "  ${GREEN}targets${NC} <file>        Load targets from file"
    echo ""
    echo -e "${CYAN}Scanning:${NC}"
    echo -e "  ${GREEN}scan${NC}                  Full automated scan"
    echo -e "  ${GREEN}scan${NC} recon            Reconnaissance only"
    echo -e "  ${GREEN}scan${NC} vulns            Vulnerability scan"
    echo -e "  ${GREEN}scan${NC} ports            Port scan"
    echo -e "  ${GREEN}scan${NC} xss              XSS testing"
    echo -e "  ${GREEN}scan${NC} sqli             SQL injection testing"
    echo -e "  ${GREEN}scan${NC} secrets          Hunt for exposed secrets"
    echo ""
    echo -e "${CYAN}Quick Tools:${NC}"
    echo -e "  ${GREEN}subdomains${NC}            Enumerate subdomains"
    echo -e "  ${GREEN}urls${NC}                  Collect URLs"
    echo -e "  ${GREEN}probe${NC}                 Probe for live hosts"
    echo -e "  ${GREEN}nuclei${NC}                Run nuclei scan"
    echo -e "  ${GREEN}fuzz${NC} <path>           Directory fuzzing"
    echo -e "  ${GREEN}whatweb${NC}               Identify technologies"
    echo ""
    echo -e "${CYAN}Results:${NC}"
    echo -e "  ${GREEN}results${NC}               Show latest scan results"
    echo -e "  ${GREEN}results${NC} list          List all scans"
    echo -e "  ${GREEN}results${NC} <scan_dir>    Show specific scan"
    echo -e "  ${GREEN}vulns${NC}                 Show found vulnerabilities"
    echo -e "  ${GREEN}report${NC}                Generate report"
    echo ""
    echo -e "${CYAN}Utilities:${NC}"
    echo -e "  ${GREEN}tools${NC}                 Check installed tools"
    echo -e "  ${GREEN}update${NC}                Update nuclei templates"
    echo -e "  ${GREEN}config${NC}                Show/edit configuration"
    echo -e "  ${GREEN}shell${NC} <cmd>           Run shell command"
    echo -e "  ${GREEN}clear${NC}                 Clear screen"
    echo -e "  ${GREEN}help${NC}                  Show this help"
    echo -e "  ${GREEN}exit${NC}                  Exit CLI"
    echo ""
}

log() { echo -e "${GREEN}[+]${NC} $1"; }
warn() { echo -e "${YELLOW}[!]${NC} $1"; }
error() { echo -e "${RED}[-]${NC} $1"; }
info() { echo -e "${BLUE}[*]${NC} $1"; }

check_target() {
    if [[ -z "$TARGET" ]]; then
        error "No target set. Use: target <domain>"
        return 1
    fi
    return 0
}

set_target() {
    local domain="$1"
    # Clean domain
    domain=$(echo "$domain" | sed 's|https\?://||' | sed 's|/.*||')
    TARGET="$domain"
    log "Target set: ${CYAN}$TARGET${NC}"
}

cmd_target() {
    if [[ -z "$1" ]]; then
        if [[ -z "$TARGET" ]]; then
            warn "No target set"
        else
            info "Current target: ${CYAN}$TARGET${NC}"
        fi
    else
        set_target "$1"
    fi
}

cmd_scan() {
    check_target || return
    
    local mode="${1:-full}"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    LAST_SCAN_DIR="$SCRIPT_DIR/results/${TARGET}_${timestamp}"
    mkdir -p "$LAST_SCAN_DIR"
    
    case "$mode" in
        full)
            log "Starting full scan on ${CYAN}$TARGET${NC}..."
            "$SCRIPT_DIR/hackstrike" "$TARGET" --full
            ;;
        recon)
            log "Starting recon on ${CYAN}$TARGET${NC}..."
            "$SCRIPT_DIR/hackstrike" "$TARGET" --recon
            ;;
        vulns)
            log "Starting vulnerability scan on ${CYAN}$TARGET${NC}..."
            "$SCRIPT_DIR/hackstrike" "$TARGET" --vulns
            ;;
        ports)
            log "Starting port scan on ${CYAN}$TARGET${NC}..."
            "$SCRIPT_DIR/hackstrike" "$TARGET" --ports
            ;;
        xss)
            log "Starting XSS testing on ${CYAN}$TARGET${NC}..."
            "$SCRIPT_DIR/hackstrike" "$TARGET" --xss
            ;;
        sqli)
            log "Starting SQLi testing on ${CYAN}$TARGET${NC}..."
            "$SCRIPT_DIR/hackstrike" "$TARGET" --sqli
            ;;
        secrets)
            log "Hunting for secrets on ${CYAN}$TARGET${NC}..."
            cmd_secrets
            ;;
        *)
            error "Unknown scan mode: $mode"
            info "Available: full, recon, vulns, ports, xss, sqli, secrets"
            ;;
    esac
}

cmd_subdomains() {
    check_target || return
    log "Enumerating subdomains for ${CYAN}$TARGET${NC}..."
    
    local outdir="$SCRIPT_DIR/results/${TARGET}_quick"
    mkdir -p "$outdir"
    
    if command -v subfinder &>/dev/null; then
        info "Running subfinder..."
        subfinder -d "$TARGET" -silent | tee "$outdir/subdomains.txt"
    fi
    
    local count=$(wc -l < "$outdir/subdomains.txt" 2>/dev/null || echo 0)
    log "Found ${GREEN}$count${NC} subdomains"
}

cmd_urls() {
    check_target || return
    log "Collecting URLs for ${CYAN}$TARGET${NC}..."
    
    local outdir="$SCRIPT_DIR/results/${TARGET}_quick"
    mkdir -p "$outdir"
    
    if command -v gau &>/dev/null; then
        info "Running gau..."
        echo "$TARGET" | gau --threads 5 | tee "$outdir/urls.txt"
    elif command -v waybackurls &>/dev/null; then
        info "Running waybackurls..."
        echo "$TARGET" | waybackurls | tee "$outdir/urls.txt"
    fi
    
    local count=$(wc -l < "$outdir/urls.txt" 2>/dev/null || echo 0)
    log "Found ${GREEN}$count${NC} URLs"
}

cmd_probe() {
    check_target || return
    log "Probing live hosts for ${CYAN}$TARGET${NC}..."
    
    if command -v httpx &>/dev/null; then
        echo "$TARGET" | httpx -silent -status-code -title -tech-detect
    fi
}

cmd_nuclei() {
    check_target || return
    log "Running nuclei on ${CYAN}$TARGET${NC}..."
    
    if command -v nuclei &>/dev/null; then
        echo "https://$TARGET" | nuclei -severity critical,high,medium -silent
    else
        error "nuclei not installed"
    fi
}

cmd_fuzz() {
    check_target || return
    local path="${1:-/}"
    log "Fuzzing ${CYAN}https://$TARGET$path${NC}..."
    
    if command -v ffuf &>/dev/null; then
        local wordlist="/usr/share/seclists/Discovery/Web-Content/common.txt"
        [[ ! -f "$wordlist" ]] && wordlist="$SCRIPT_DIR/wordlists/common/directories.txt"
        
        if [[ -f "$wordlist" ]]; then
            ffuf -u "https://$TARGET${path}FUZZ" -w "$wordlist" -mc 200,301,302,403 -t 50
        else
            error "No wordlist found"
        fi
    else
        error "ffuf not installed"
    fi
}

cmd_whatweb() {
    check_target || return
    log "Identifying technologies on ${CYAN}$TARGET${NC}..."
    
    if command -v whatweb &>/dev/null; then
        whatweb -a 3 "https://$TARGET"
    elif command -v httpx &>/dev/null; then
        echo "$TARGET" | httpx -silent -tech-detect -status-code -title
    fi
}

cmd_secrets() {
    check_target || return
    log "Hunting for secrets on ${CYAN}$TARGET${NC}..."
    
    # Check .git
    info "Checking .git exposure..."
    if curl -sk --max-time 5 "https://$TARGET/.git/HEAD" 2>/dev/null | grep -q 'ref:'; then
        echo -e "${RED}[VULN]${NC} .git directory exposed: https://$TARGET/.git/"
    fi
    
    # Check .env
    info "Checking .env exposure..."
    if curl -sk --max-time 5 "https://$TARGET/.env" 2>/dev/null | grep -qiE '(DB_|APP_|API_|SECRET)'; then
        echo -e "${RED}[VULN]${NC} .env file exposed: https://$TARGET/.env"
    fi
    
    # Check common files
    local files=(".git/config" ".svn/entries" "wp-config.php.bak" ".htaccess" "web.config" "phpinfo.php" ".DS_Store" "server-status" "debug.log")
    for file in "${files[@]}"; do
        local status=$(curl -sk --max-time 3 -o /dev/null -w "%{http_code}" "https://$TARGET/$file")
        if [[ "$status" == "200" ]]; then
            echo -e "${YELLOW}[FOUND]${NC} https://$TARGET/$file (HTTP $status)"
        fi
    done
    
    log "Secret hunting complete"
}

cmd_results() {
    local arg="$1"
    local results_dir="$SCRIPT_DIR/results"
    
    if [[ "$arg" == "list" ]]; then
        info "Available scan results:"
        ls -lt "$results_dir" 2>/dev/null | head -20
    elif [[ -n "$arg" && -d "$results_dir/$arg" ]]; then
        info "Results for: $arg"
        ls -la "$results_dir/$arg"
    else
        # Show latest
        local latest=$(ls -td "$results_dir"/*/ 2>/dev/null | head -1)
        if [[ -n "$latest" ]]; then
            info "Latest scan: ${CYAN}$latest${NC}"
            echo ""
            if [[ -f "$latest/reports/report.md" ]]; then
                cat "$latest/reports/report.md"
            else
                ls -la "$latest"
            fi
        else
            warn "No scan results found"
        fi
    fi
}

cmd_vulns() {
    local results_dir="$SCRIPT_DIR/results"
    local latest=$(ls -td "$results_dir"/*/ 2>/dev/null | head -1)
    
    if [[ -n "$latest" ]]; then
        info "Vulnerabilities from: ${CYAN}$latest${NC}"
        echo ""
        if [[ -f "$latest/vulns/nuclei.txt" ]]; then
            cat "$latest/vulns/nuclei.txt"
        fi
        if [[ -f "$latest/exploits/xss.txt" ]]; then
            echo -e "\n${RED}XSS Findings:${NC}"
            cat "$latest/exploits/xss.txt"
        fi
        if [[ -f "$latest/exploits/sqli.txt" ]]; then
            echo -e "\n${RED}SQLi Findings:${NC}"
            cat "$latest/exploits/sqli.txt"
        fi
    else
        warn "No vulnerability results found"
    fi
}

cmd_tools() {
    info "Checking installed tools..."
    echo ""
    
    local tools=(subfinder amass httpx nuclei nmap ffuf gobuster dalfox sqlmap gau waybackurls katana naabu whatweb nikto wpscan)
    
    for tool in "${tools[@]}"; do
        if command -v "$tool" &>/dev/null; then
            echo -e "  ${GREEN}???${NC} $tool"
        else
            echo -e "  ${RED}???${NC} $tool"
        fi
    done
}

cmd_update() {
    log "Updating nuclei templates..."
    if command -v nuclei &>/dev/null; then
        nuclei -update-templates
    else
        error "nuclei not installed"
    fi
}

cmd_shell() {
    local cmd="$*"
    if [[ -n "$cmd" ]]; then
        eval "$cmd"
    else
        warn "Usage: shell <command>"
    fi
}

# Main command processor
process_command() {
    local input="$1"
    local cmd=$(echo "$input" | awk '{print $1}')
    local args=$(echo "$input" | cut -d' ' -f2-)
    [[ "$args" == "$cmd" ]] && args=""
    
    case "$cmd" in
        ""|" ")
            ;;
        target)
            cmd_target "$args"
            ;;
        targets)
            if [[ -f "$args" ]]; then
                info "Loaded targets from: $args"
                cat "$args"
            else
                error "File not found: $args"
            fi
            ;;
        scan)
            cmd_scan "$args"
            ;;
        subdomains|subs)
            cmd_subdomains
            ;;
        urls)
            cmd_urls
            ;;
        probe|live)
            cmd_probe
            ;;
        nuclei)
            cmd_nuclei
            ;;
        fuzz|ffuf)
            cmd_fuzz "$args"
            ;;
        whatweb|tech)
            cmd_whatweb
            ;;
        secrets)
            cmd_secrets
            ;;
        results|res)
            cmd_results "$args"
            ;;
        vulns|vulnerabilities)
            cmd_vulns
            ;;
        report)
            cmd_results
            ;;
        tools|check)
            cmd_tools
            ;;
        update)
            cmd_update
            ;;
        config)
            info "Target: ${TARGET:-not set}"
            info "Results dir: $SCRIPT_DIR/results"
            info "History: $HISTORY_FILE"
            ;;
        shell|sh|!)
            cmd_shell "$args"
            ;;
        clear|cls)
            banner
            ;;
        help|h|\?)
            print_help
            ;;
        exit|quit|q)
            echo -e "${CYAN}Happy hunting! ????${NC}"
            exit 0
            ;;
        *)
            error "Unknown command: $cmd"
            info "Type 'help' for available commands"
            ;;
    esac
}

# Tab completion
complete_commands() {
    local commands="target targets scan subdomains urls probe nuclei fuzz whatweb secrets results vulns report tools update config shell clear help exit"
    COMPREPLY=($(compgen -W "$commands" -- "${COMP_WORDS[COMP_CWORD]}"))
}

# Main loop
main() {
    banner
    
    # Check for target argument
    if [[ -n "$1" ]]; then
        set_target "$1"
    fi
    
    info "Welcome to HackStrike CLI"
    [[ -n "$TARGET" ]] && info "Target: ${CYAN}$TARGET${NC}"
    echo ""
    
    # Interactive loop
    while true; do
        # Build prompt
        local prompt=""
        if [[ -n "$TARGET" ]]; then
            prompt="${PURPLE}hackstrike${NC}(${CYAN}$TARGET${NC})> "
        else
            prompt="${PURPLE}hackstrike${NC}> "
        fi
        
        echo -ne "$prompt"
        read -r -e input
        
        # Skip empty
        [[ -z "$input" ]] && continue
        
        # Add to history
        history -s "$input"
        
        # Process
        process_command "$input"
        echo ""
    done
}

main "$@"
